"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9136],{6719:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>r,toc:()=>h});var t=n(4848),s=n(8453);const l={},o="Cycles",r={id:"rendering/cycles",title:"Cycles",description:"General",source:"@site/docs/rendering/cycles.md",sourceDirName:"rendering",slug:"/rendering/cycles",permalink:"/docs/rendering/cycles",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/rendering/cycles.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Corona",permalink:"/docs/rendering/corona"},next:{title:"Rendering",permalink:"/docs/rendering/index (LAPTOP-ECKQA8BC's conflicted copy 2024-09-20)"}},a={},h=[{value:"General",id:"general",level:3},{value:"Volume Rendering",id:"volume-rendering",level:3},{value:"Optimization",id:"optimization",level:3},{value:"Gobo",id:"gobo",level:3},{value:"Node Studies",id:"node-studies",level:3}];function c(e){const i={a:"a",h1:"h1",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"cycles",children:"Cycles"}),"\n",(0,t.jsx)(i.h3,{id:"general",children:"General"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Baking Textures.","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Create an empty texture node with a new blank texture file."}),"\n",(0,t.jsx)(i.li,{children:"Need to be in cycles"}),"\n",(0,t.jsx)(i.li,{children:"Click on that node and also the object."}),"\n",(0,t.jsx)(i.li,{children:"Go to cycle settings then bake."}),"\n",(0,t.jsx)(i.li,{children:"Caveat with a metallic material. Need to make it zero first when baking."}),"\n",(0,t.jsx)(i.li,{children:"Need to also have the correct color space with baking."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.li,{children:"Bump node in cycles will be the one that combines normal and bump ma."}),"\n",(0,t.jsx)(i.li,{children:"tiling in blender. texture coordinate (UV) > (Vector) mapping (Vector) node. > Texture (Map). In the point tab. Modify scale."}),"\n",(0,t.jsx)(i.li,{children:"Use generated if its an HDRI"}),"\n",(0,t.jsx)(i.li,{children:"Reflective/Refractive Caustics"}),"\n",(0,t.jsx)(i.li,{children:"Caustics is for indirect lighting"}),"\n",(0,t.jsx)(i.li,{children:"Faking caustics. How?"}),"\n",(0,t.jsx)(i.li,{children:"Cycles4d is ported over from Blender which uses XYZ axis mapping. C4D uses XZY mapping."}),"\n",(0,t.jsx)(i.li,{children:"You need to specify the displacement per se. By default, its only for bump"}),"\n",(0,t.jsx)(i.li,{children:"In the materials>Settings>Surface>Displacement"}),"\n",(0,t.jsx)(i.li,{children:"Ctrl Shift +D to duplciate node but still connected"}),"\n",(0,t.jsx)(i.li,{children:"Shift R to repeat th process"}),"\n",(0,t.jsx)(i.li,{children:"Getting the normals in the landscape tutorial: Geometry (normal) > (normal) Normal (dot) > (fac) Color Ramp"}),"\n",(0,t.jsx)(i.li,{children:"Creating waves. just normal in the gloss shader."}),"\n",(0,t.jsx)(i.li,{children:"A couple of things to pay attention to with fluid regarding materials is the IOR (Index of Refraction). You can use a Glass Shader for most liquids. For something like milk you\u2019ll want an SSS Shader (Sub-Surface Scattering). For something like wine though, go with a Glass Shader."}),"\n",(0,t.jsx)(i.li,{children:"Another thing you might try is using a Volume Absorption Shader in conjunction with your Glass Shader to make your wine look thicker where it is denser. Red wine has sediment, so it will be a much deeper red the further in you go. A Volume Absorption Shader can help you get this look. Play with the \u201cDensity\u201d value until you get something that looks right to you."}),"\n",(0,t.jsx)(i.li,{children:"In Cycles4D, to get an alpha. you need the native c4d alpha channel tick and also the film transparent."}),"\n",(0,t.jsx)(i.li,{children:"blender. shader to rgb node?"}),"\n",(0,t.jsx)(i.li,{children:"principle shader > shader to rgb > ramp > material output>"}),"\n",(0,t.jsx)(i.li,{children:"If we want to control this manually ourselves we can simply add a gamma node set to 0.454 (linear to sRGB) or 2.2 (sRGB to linear) instead of switching that non-color setting."}),"\n",(0,t.jsx)(i.li,{children:"So as shown a height map used for a bump node and that same height map converted to a normal map and then plugged in a normal map node will shade differently. That is something we may need to bare in mind, to the point where we may want to tweak the shader settings, the specularity of lamps and the bump strength to make them look more similar to each other."}),"\n",(0,t.jsx)(i.li,{children:"Normal Map Texture > Normap Map > Normal Map (Principlied BSDF)"}),"\n",(0,t.jsx)(i.li,{children:"What if you want to have normal and height? You use the Bump Map. I know confusing."}),"\n",(0,t.jsx)(i.li,{children:"Noise: Manifest in It manifests in one of two ways: grain and fireflies."}),"\n",(0,t.jsx)(i.li,{children:"Regarding the fireflies: In this case throwing more samples at the problem won\u2019t get rid of the problem completely."}),"\n",(0,t.jsx)(i.li,{children:"Blurring glossy reflections slightly will reduce fireflies."}),"\n",(0,t.jsx)(i.li,{children:"Using the Filter Glossy control to blur glossy reflections will reduce fireflies."}),"\n",(0,t.jsx)(i.li,{children:"Increasing the light size will reduce and may abolish fireflies"}),"\n",(0,t.jsx)(i.li,{children:"Turning off multiple importance sampling for a light will remove fireflies but also other important lighting components."}),"\n",(0,t.jsx)(i.li,{children:"In fact, Cycles 4D has two types of caustics, reflective and refractive,"}),"\n",(0,t.jsx)(i.li,{children:"Which is pretty good, but remember that in many cases you will want those caustics! You will also lose indirect lighting from the sphere, which may be undesirable."}),"\n",(0,t.jsx)(i.li,{children:"Use Clamp Direct and/or Clamp Indirect to control fireflies."}),"\n",(0,t.jsx)(i.li,{children:"To simplify that stuff, I\u2019ll just say that many objects are more reflective the more their surfaces are angled away from the view. On the contrary, metals are not, so they are equally reflective at all angles. In another words, it depends on Fresnel coefficient."}),"\n",(0,t.jsx)(i.li,{children:"To create a convincing illusion of depth inside the ice, place something right inside your cube of frozen water. For example, insert another piece of ice"}),"\n",(0,t.jsx)(i.li,{children:"Add Translucent to the refractive shader for the ice thing ray length node"}),"\n",(0,t.jsx)(i.li,{children:"Try clamping indirect samples even more: maybe something like 1 or even 0.3?"}),"\n",(0,t.jsx)(i.li,{children:"Also, enable Multiple Importance Sampling in the background settings. And set its value to 1024 or 2048. Hopefully, that should reduce noise (even without clamping)."}),"\n",(0,t.jsx)(i.li,{children:"Soft shadows are going to be noisy. That problem can be solved in Branched Path Tracer. Turn up the light samples count in the light source."}),"\n",(0,t.jsx)(i.li,{children:"Big Light is equal to soft light"}),"\n",(0,t.jsx)(i.li,{children:"Dirk follows with a great tip: \u201cWhen you photograph something that needs a softer touch, move the light closer to your subject or add a diffusion device like a soft box or umbrella.\u201d"}),"\n",(0,t.jsx)(i.li,{children:"In another words, move the light closer or make it bigger."}),"\n",(0,t.jsx)(i.li,{children:"How does the clamp work? When the pixel brightness goes over some value, the clamp prevents it from getting brighter. So, set it to 1 to keep lighting at bay."}),"\n",(0,t.jsx)(i.li,{children:"Yes soft light is about having a big light source up close but there is another point; fade out. Basically if you have a light that is VERY close to the model it will change intensity very quickly with distance because of the formula intensity = 1/(distance squared) . This means that the models nose will be quite bright but as you come to the ears the light as already fading out quite a lot."}),"\n",(0,t.jsx)(i.li,{children:"The sun can\u2019t penetrate a deep fog layer, so the light reaching the ground seems to come from all directions."}),"\n",(0,t.jsx)(i.li,{children:"Now compare it to a day lighting. During a daytime, you see only one dominant light source, plus the softbox of the sky. On the contrary, the night throws hundreds of small light sources at us.."}),"\n",(0,t.jsx)(i.li,{children:"If you want to create an awesome night highway lighting setup, be ready to handle 10, 20, 100 light sources. Tiny, sharp, and overly bright for sure."}),"\n",(0,t.jsx)(i.li,{children:"Have you ever noticed that night doesn\u2019t feature soft lights? As the lamps are small, and the city is nothing more than a distant glowing chain, the shadows are very hard."}),"\n",(0,t.jsx)(i.li,{children:"When light is refracted through the dirt windshield and then passes through the lens of your eye, you see an overwhelming lens flare. It often looks like a streaks of light, stretching into different directions. Sometimes, it looks like a quasar: a huge vertical ray."}),"\n",(0,t.jsx)(i.li,{children:"Honestly, I find that SSS and Translucent shader with raylength node plugged in behave in very similar way. Though, it becomes the matter of personal preference. Yes, I would recommend SSS for grapes \ud83d\ude42"}),"\n",(0,t.jsx)(i.li,{children:"Form what I\u2019ve found you don\u2019t need more than 256 samples with de noosing turned on unless you\u2019re doing volumetrics"}),"\n",(0,t.jsx)(i.li,{children:"you can\u2019t render if the camera is inside the volume"}),"\n",(0,t.jsx)(i.li,{children:"slope equals speed"}),"\n",(0,t.jsx)(i.li,{children:"light size. need to have more samples if it is smmaller"}),"\n",(0,t.jsx)(i.li,{children:"density is 0.002"}),"\n",(0,t.jsx)(i.li,{children:"anistorphy 0.5"}),"\n",(0,t.jsx)(i.li,{children:"WTF?"}),"\n",(0,t.jsx)(i.li,{children:"map range node better than color ramp."}),"\n",(0,t.jsx)(i.li,{children:"in volume. it\u2019s almost always necessary for the BPT tracing."}),"\n",(0,t.jsx)(i.li,{children:"Bounces 0: Volume samples 4"}),"\n",(0,t.jsx)(i.li,{children:"volume anistorpy is a somewhat fall-off. more anistorpy means (i.e. closer 1). it will closer to the light source)"}),"\n",(0,t.jsx)(i.li,{children:"to preview node. hold the node and Ctrl+Shift+LMB"}),"\n",(0,t.jsxs)(i.li,{children:["more info ",(0,t.jsx)(i.a,{href:"https://gregzaal.github.io/node-wrangler/",children:"https://gregzaal.github.io/node-wrangler/"})]}),"\n",(0,t.jsx)(i.li,{children:"Metal no diffuse color. Color comes in tintid reflection"}),"\n",(0,t.jsx)(i.li,{children:"sun has no decay"}),"\n",(0,t.jsx)(i.li,{children:"using the poitiness in the geometry node to determine the peaks and highs."}),"\n",(0,t.jsx)(i.li,{children:"box texture > blend is quals to triplanar"}),"\n",(0,t.jsx)(i.li,{children:"Homogeneous Volume. Assume volume has the same density everywhere (not using any textures), for faster rendering."}),"\n",(0,t.jsx)(i.li,{children:"HDRI Lighting: Not really an object but through a separate setting. Click on the world Tab. Import HDRI Texture. To rotate, change vector>mapping and vector>texture coordinated."}),"\n",(0,t.jsx)(i.li,{children:"World Settings>Multiple importance sampling. Only available in using HDRI"}),"\n",(0,t.jsx)(i.li,{children:"Remove fireflies: increase or match map resolution setting to the HDRI map.]"}),"\n",(0,t.jsx)(i.li,{children:"Get rid of fireflies? Aside from increase samples, use clamping."}),"\n",(0,t.jsx)(i.li,{children:"Try to avoid alpha transparency if there are better ways (i.e. 29 min vs 16 min)"}),"\n",(0,t.jsx)(i.li,{children:"Scene>Use GPU Compute"}),"\n",(0,t.jsx)(i.li,{children:"Reduce max light bounce. Default is 12. You can get by 5 or 6."}),"\n",(0,t.jsx)(i.li,{children:"Shift+Ctrl+Click on the Node to render it directly."}),"\n",(0,t.jsx)(i.li,{children:"View the texture in blender. Blender View. Select all the components and select the texture dropdown in the UV/Image Editor. On the Cycles Render. Have to add a node. Also press N for the shadeless render"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"volume-rendering",children:"Volume Rendering"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"By default, Cycles4D sets Step Size at 10. Set Step size to 1."}),"\n",(0,t.jsx)(i.li,{children:"Houdini Pyro to Blender Cycles\nFor testing, export default Pyro Explosion Shelf set-up from houdini to VDB.\nImport it with the new volume object container (2.83)\nDensity (25). Black body Intensity (1000). Temperature (4000). Temperature Attr (Heat)"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"optimization",children:"Optimization"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Limit the number of bounces to four, and you will experience incredible render speed."}),"\n",(0,t.jsx)(i.li,{children:"In practice more bounces will introduce more noise, and it might be good to use something like the Limited Global Illumination preset in the Light Paths Section that uses fewer bounces for different shader types. ."}),"\n",(0,t.jsx)(i.li,{children:"Diffuse surfaces typically can get away with fewer bounces, while glossy surfaces need a few more, and transmission shaders such as glass usually need the most"}),"\n",(0,t.jsx)(i.li,{children:"Also important is to use shader colors that do not have components of value 1.0 or values near that; try to keep the maximum value to 0.8 or less and make your lights brighter."}),"\n",(0,t.jsx)(i.li,{children:"High values for the color components tend to introduce noise because light intensity then does not decrease much as it bounces off each surface."}),"\n",(0,t.jsx)(i.li,{children:"Turn off some lamp\u2019s shadows, using only one or two main sun lamps to cast shadows. A few \u201cshadows only\u201d lights will render faster than every light having shadows on."}),"\n",(0,t.jsx)(i.li,{children:"On Clamping: If set too low this can cause missing highlights in the image, which might be useful to preserve for camera effects such as bloom or glare. To mitigate this conundrum it\u2019s often useful to clamp only indirect bounces, leaving highlights directly visible to the camera untouched."}),"\n",(0,t.jsx)(i.li,{children:"When you decrease \u201cmax steps\u201d, you will decrease the number of bounces the render engine has to calculate before a light ray is turned off."}),"\n",(0,t.jsx)(i.li,{children:"In reality light in a vacuum will always fall off at a rate of 1/(distance^2). However, as distance goes to zero, this value goes to infinity and we can get very bright spots in the image. These are mostly a problem for indirect lighting, where the probability of hitting such a small but extremely bright spot is low and so happens only rarely. This is a typical recipe for fireflies."}),"\n",(0,t.jsx)(i.li,{children:"To reduce this problem, the Light Falloff node has a Smooth factor, that can be used to reduce the maximum intensity a light can contribute to nearby surfaces. The images above show default falloff and smooth value 1.0."}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"gobo",children:"Gobo"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Normal to vector mapping for light textures and gobo"}),"\n",(0,t.jsx)(i.li,{children:"as a light texture pala ito"}),"\n",(0,t.jsx)(i.li,{children:"does not work with sunlight"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"References"})}),"\n",(0,t.jsx)(i.h3,{id:"node-studies",children:"Node Studies"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://docs.google.com/presentation/d/1ggss5H_XdWtIZ825iRuUjk7svvzdoPWM-cP1yv4kCCc/edit?fbclid=IwAR3TWwNcU2z7mw0iZmzmWcEwdPEOh-RxeiADkz2opB9_PKACCWzXq_KQ5Z4#slide=id.g500010a94b9d5336_9",children:"https://docs.google.com/presentation/d/1ggss5H_XdWtIZ825iRuUjk7svvzdoPWM-cP1yv4kCCc/edit?fbclid=IwAR3TWwNcU2z7mw0iZmzmWcEwdPEOh-RxeiADkz2opB9_PKACCWzXq_KQ5Z4#slide=id.g500010a94b9d5336_9"})}),"\n"]})]})}function d(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var t=n(6540);const s={},l=t.createContext(s);function o(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);