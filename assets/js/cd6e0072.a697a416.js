"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[94],{97:(a,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>m,default:()=>o,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var t=n(4848),r=n(8453);const i={},m=void 0,l={id:"maya/programming/example/list_materials_in_a_scene_3DS_max",title:"list_materials_in_a_scene_3DS_max",description:"ss",source:"@site/docs/maya/programming/example/list_materials_in_a_scene_3DS_max.md",sourceDirName:"maya/programming/example",slug:"/maya/programming/example/list_materials_in_a_scene_3DS_max",permalink:"/docs/maya/programming/example/list_materials_in_a_scene_3DS_max",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/maya/programming/example/list_materials_in_a_scene_3DS_max.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Linear Interpolation Expression Based",permalink:"/docs/maya/programming/example/linear_interpolation_expression_base"},next:{title:"Recreate Groups from Houdini to Maya",permalink:"/docs/maya/programming/example/recreate_groups_from_houdini_to_maya/recreate_groups_from_houdini_to_maya"}},s={},p=[];function _(a){const e={code:"code",p:"p",pre:"pre",...(0,r.R)(),...a.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"ss"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"import pymxs\nimport logging\nimport json\n\nrt = pymxs.runtime\nlogging.basicConfig(level=logging.WARNING, format='%(asctime)s - %(levelname)s - %(message)s')\n\nvray_sss_param = ['scale', 'IOR', 'overall_color', 'sub_surface_color','scatter_color',\n'scatter_radius', 'phase_function', 'specular_amount', 'specular_glossiness', \n'texmap_bump', 'texmap_bump_multiplier',\n'texmap_specular_amount', 'texmap_specular_amount_multiplier',\n'texmap_sss_color', 'texmap_sss_color_multiplier',\n'texmap_scatter_color']\n\nvray_mtl_param = ['reflection_glossiness', 'reflection_ior',\n'texmap_diffuse', 'texmap_diffuse_multiplier', 'texmap_bump', 'texmap_bump_multiplier', 'Diffuse', 'Reflection', 'texmap_opacity']\n\nstandard_mtl_param = ['ior', 'bumpMap', 'bumpMapAmount', 'diffuseMap', 'diffuseMapAmount', 'opacityMap', 'Diffuse', 'Specular']\n\nvray_alsurface_mtl_param = ['displacement_texture', 'diffuse_color_texture', 'diffuse_color', 'sss_mix', 'opacity_texture', 'opacity', 'diffuse_bump', 'refl1_strength', 'bump_texture', 'diffuse_strength', 'sss_mix', 'reflect1_ior', 'reflect1_roughness', 'reflect1_roughness_texture']\n\nphysical_mat_param = ['base_color', 'base_color_map', 'roughness', 'Roughness_Map', 'transparency', 'transparency_map', 'trans_ior', 'bump_map', 'bump_map_amt']\n\ntexmap = ['texmap_bump', 'texmap_sss_color', 'texmap_diffuse', 'texmap_bump', 'bumpMap']\n\n\ndef list_objects_with_material(material_name):\n    rt = pymxs.runtime\n    \n    # Get the material by name\n    material = None\n    for m in rt.sceneMaterials:\n        if m.name == material_name:\n            material = m\n            break\n    \n    if material is None:\n        #print(f\"Material '{material_name}' not found in the scene.\")\n        return []\n    \n    # List all objects with the specified material\n    objects_with_material = []\n    for obj in rt.geometry:\n        if obj.material == material:\n            objects_with_material.append(obj.name)\n    \n    return objects_with_material\n\n\ndef list_all_materials():\n    rt = pymxs.runtime\n\n    # List to store all unique materials\n    all_materials = set()\n\n    # Function to recursively collect materials from a material tree\n    def collect_materials(material):\n        if not material:\n            return\n        if material not in all_materials:\n            #all_materials.add(material)\n            # Check for sub-materials if it's a Multi/Sub-Object material\n            if rt.isKindOf(material, rt.MultiSubMaterial):\n                #print (material)\n                for mat in material.materialList:\n                    if mat == None:\n                        continue\n                    all_materials.add(mat)\n                    # print (mat, type(mat))\n\n                #print (\"=======\")\n                #print (material.name)\n                #print (material.name)\n                # for i in range(1, material.numsubs + 1):\n                #     sub_material = material[i]\n                #     if sub_material:\n                #         collect_materials(sub_material)\n            # Check for other types of sub-materials\n            elif rt.isKindOf(material, rt.Material):\n                all_materials.add(material)\n                \n                #print (material, rt.classOf(material).__str__())\n                \n                #print (material.name)\n                # for i in range(material.numSubs):\n                #     sub_material = material.getSubMtl(i + 1)\n                #     if sub_material:\n                #         collect_materials(sub_material)\n            else:\n                print (\"what is this?\", material)\n\n    # Iterate through all nodes in the scene and collect materials\n    for node in rt.objects:\n        if hasattr(node, \"material\") and node.material:\n            collect_materials(node.material)\n\n    #Print all unique materials\n    # for material in all_materials:\n    #     print(material.name)\n\n    return all_materials\n\n# Run the function\nmat_list = list_all_materials()\nmat_conversion = {}\n#print (mat_list)\n\n\nfor mat in mat_list:\n\n    mat_param = {}\n\n    if mat is None:\n        continue\n        \n    mat_name = mat.name\n    # if mat_name != \"Parotid\":\n    #     continue\n\n    # prop_list = rt.getPropNames(mat)\n    # for p in prop_list:\n    #     print (p, getattr(mat, p.__str__()))\n\n    mat_type = rt.classOf(mat).__str__()\n    logging.debug(f\"Material type: {mat_type}\")\n\n    if mat_type == \"VRayFastSSS2\":\n        param_list = vray_sss_param\n        \n    elif mat_type == \"VRayMtl\":\n        param_list = vray_mtl_param\n        \n    elif mat_type == \"Standard\" or mat_type == \"Standardmaterial\":\n        param_list = standard_mtl_param\n\n    elif mat_type == \"VRayALSurfaceMtl\":\n        param_list = vray_alsurface_mtl_param\n\n    elif mat_type == \"PhysicalMaterial\":\n        param_list = physical_mat_param\n\n    else:\n        logging.warning(f\"Material: {mat_name} | Type: {mat_type} configuration not found\")\n        continue\n\n    # m = getattr(mat, 'texmap_specular_amount')\n    # print ((m.filename))\n\n    obj_assigned = list_objects_with_material(mat_name)\n    # logging.debug(f\"Objects assigned: {obj_assigned}\")  \n\n    for param in param_list:\n        # if param != \"diffuse_bump\":\n        #     continue\n\n        \n        value = getattr(mat, param)\n        logging.debug(f\"{mat_name} --- {param} --- {value}\")\n\n        #print (value, rt.classOf(value).__str__())\n        \n        #print (rt.classOf(value))\n        #print (rt.classOf(value).__str__())\n        #print (rt.getPropNames(value))\n        #print (value.GetTileTextures(1))\n        #print (value.getTileTexmap(1).filename )\n        #print (str(value.filename))\n        #print (dir(value))\n        #print (rt.getPropNames(value))\n\n        #print (rt.classOf(value).__str__())\n\n        #print (param, rt.classOf(value).__str__())\n        if rt.classOf(value).__str__() == \"Bitmaptexture\":\n            mat_param[param] = str(value.filename)\n\n        elif rt.classOf(value).__str__() == \"MultiTile\":\n            #print (str(value.getTileTexmap(1).filename))\n            #print (\"weee\")\n            #print ()\n            \n            #print (len(str(value.getTileTexmap(2).filename)))\n            tex_map_1 = str(value.getTileTexmap(1).filename)\n\n            if len(tex_map_1) > 3:\n                mat_param[param] = tex_map_1\n            else:\n                mat_param[param] = str(value.getTileTexmap(2).filename) \n\n            #print (mat_param[param])\n\n        elif rt.classOf(value).__str__() == \"VRayNormalMap\":\n\n            connected_node = value.normal_map\n            \n\n            if rt.classOf(connected_node).__str__() == \"Bitmaptexture\":\n                mat_param[param] = str(connected_node.filename)\n\n            if rt.classOf(connected_node).__str__() == \"MultiTile\":\n                #mat_param[param] = str(connected_node.getTileTexmap(1).filename)\n\n                ex_map_1 = str(connected_node.getTileTexmap(1).filename)\n\n                if len(tex_map_1) > 3:\n                    mat_param[param] = tex_map_1\n                else:\n                    mat_param[param] = str(connected_node.getTileTexmap(2).filename) \n\n\n            # print (mat)\n            # print (value.normal_map.filename)\n\n            #print (\"=====\")\n            #print (str(value.getTileTexmap(1).filename))\n\n            #print (value)\n            #mat_param[param] = str(value.HDRIMapName)\n\n            '''\n            prop_list = rt.getPropNames(value)\n            for prop in prop_list:\n                #print (type(value), type(prop.__str__()))\n                number = getattr(value, prop.__str__())\n                print (prop, number)\n\n                value.normal_map.filename\n            '''\n\n        elif rt.classOf(value).__str__() == \"VRayBitmap\":\n            #print (str(value.getTileTexmap(1).filename))\n\n            mat_param[param] = str(value.HDRIMapName)\n            #print (str(value.HDRIMapName))\n\n            # prop_list = rt.getPropNames(value)\n            # for prop in prop_list:\n            #     #print (type(value), type(prop.__str__()))\n            #     number = getattr(value, prop.__str__())\n            #     print (prop, number)\n\n            #     HDRIMapName\n                #print (prop, prop.value)\n                # prop_value = rt.getUserProp(value, prop)\n                # print (prop, prop_value)\n\n\n            #break\n            #mat_param[param] = str(value.getTileTexmap(1).filename)\n            #print (mat_param[param])\n\n        # elif rt.classOf(value).__str__() == \"VRayTriplanarTex\":\n        #     #print (str(value.getTileTexmap(1).filename))\n        #     mat_param[param] = str(value.getTileTexmap(1).filename)\n        #     #print (mat_param[param])\n\n        elif rt.classOf(value).__str__() == \"VRayColor\":\n            mat_param[param] = [value.red, value.blue, value.green]\n\n        elif rt.classOf(value).__str__() == \"falloff\":\n            mat_param[param] = [value.color1.red, value.color1.green, value.color1.blue]\n\n        else:\n            if \"color\" in str(value).lower():\n                data = str(value).strip(\"(\").strip(\")\").split(\" \")\n                data = data[1:] # remove the color string\n                data_tuple = tuple(data) # convert list to tuple\n                mat_param[param] = data_tuple\n            elif \"Map #\" in str(value):\n                mat_param[param] = None\n            else:\n                mat_param[param] = str(value)\n\n            # Changed from material centric to object centric\n            mat_conversion.update(\n                {mat_name: {\"mat_type\": mat_type,\n                            \"mat_param\": mat_param,\n                            \"objs_assigned\": obj_assigned\n                            }\n                }\n            )            \n    \n\n\nprint (mat_conversion)\nwith open(\"C:/Users/BT/Desktop/TEMP_female_material_20240604c.json\", \"w\") as write_file:\n    json.dump(mat_conversion, write_file, indent=4)\n\nprint (\"Export success\")\n"})})]})}function o(a={}){const{wrapper:e}={...(0,r.R)(),...a.components};return e?(0,t.jsx)(e,{...a,children:(0,t.jsx)(_,{...a})}):_(a)}},8453:(a,e,n)=>{n.d(e,{R:()=>m,x:()=>l});var t=n(6540);const r={},i=t.createContext(r);function m(a){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof a?a(e):{...e,...a}}),[e,a])}function l(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(r):a.components||r:m(a.components),t.createElement(i.Provider,{value:e},a.children)}}}]);