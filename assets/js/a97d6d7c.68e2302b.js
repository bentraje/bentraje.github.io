"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1152],{3135:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>m});var i=t(4848),o=t(8453);const a={},r="Programming",s={id:"post-production/after-effects/programming",title:"Programming",description:"- Can do with expressions",source:"@site/docs/post-production/after-effects/programming.md",sourceDirName:"post-production/after-effects",slug:"/post-production/after-effects/programming",permalink:"/docs/post-production/after-effects/programming",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/post-production/after-effects/programming.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Newton",permalink:"/docs/post-production/after-effects/plugins/newton"},next:{title:"Resources",permalink:"/docs/post-production/after-effects/resources"}},l={},m=[];function d(n){const e={a:"a",code:"code",h1:"h1",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{id:"programming",children:"Programming"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Can do with expressions"}),"\n",(0,i.jsx)(e.li,{children:"Can do with the javascript"}),"\n",(0,i.jsx)(e.li,{children:"Can do with UI"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:'loopOut(type = "cycle", numKeyframes = 0)'}),"\n",(0,i.jsx)(e.h1,{id:"expressions",children:"Expressions"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{}),"\n",(0,i.jsxs)(e.li,{children:["The ending values especially with array should be at the last line","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"[700, 400, index]  (p position with 3d enabled.)"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{}),"\n",(0,i.jsx)(e.li,{children:"You can find a list of expressions in the pop out."}),"\n",(0,i.jsxs)(e.li,{children:["modulo for quantizing","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"test_val = (time%24)*100"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://ae-scripting.docsforadobe.dev/",children:"https://ae-scripting.docsforadobe.dev/"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"http://yearbook.github.io/esdocs/#/ScriptUI/Window%5C",children:"http://yearbook.github.io/esdocs/#/ScriptUI/Window\\"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://scriptui.joonas.me/",children:"https://scriptui.joonas.me/"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://ae-scripting.docsforadobe.dev/introduction/objectmodel.html",children:"https://ae-scripting.docsforadobe.dev/introduction/objectmodel.html"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://reelsmart.co/expression-library/",children:"https://reelsmart.co/expression-library/"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://aereference.com/expressions",children:"https://aereference.com/expressions"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.img,{alt:"Alt text",src:t(1683).A+"",width:"598",height:"463"})}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'loopOut("pingpong")\nsource_text.text.sourceText.style.setFontSize().setFillColor()\n\n'})}),"\n",(0,i.jsx)(e.p,{children:"You can use linear() to remap a range, like this:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'input = effect("Slider Control")("Slider");\ninputLow = 0;\ninputHigh = 100;\noutputLow = -100;\noutputHigh = 100;\n\nlinear(input,inputLow,inputHigh,outputLow,outputHigh)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'After Effects Expression\n\nIF YOU WANT TO ADD EXPRESSIONS, DO IT AT THE BOTTOM OF THE DOCUMENT\n\nInertial Bounce is like making your moves "rubbery." Layers will overextend, then settle into place on position and rotation keyframes.\n\n// Inertial Bounce (moves settle into place after bouncing around a little)\namp = .1;\nfreq = 2.0;\ndecay = 2.0;\nn = 0;\nif (numKeys > 0){\nn = nearestKey(time).index;\nif (key(n).time > time){\nn--;\n}}\nif (n == 0){ t = 0;\n}else{\nt = time - key(n).time;\n}\nif (n > 0 && t < 1){\nv = velocityAtTime(key(n).time - thisComp.frameDuration/10);\nvalue + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);                             }else{value}\n\n\n//Takes 3d space of layer and converts to 2d screen space\n\nthisComp.layer("Light 1").toComp([0,0,0]);\n\n//Takes 2D position (not world space) and uses it to position 3D objects in screen \n\nL = thisComp.layer("Null 1");\nvalue + fromCompToSurface(L.position);\n\n\n\n\nJumpy Wiggle 1 makes wiggle skip and hold rather than move fluidly.\n\n// Jumpy Wiggle 1 (moves at a random FPS)\nv=wiggle(5,50);\nif(v < 50)v=0;\nif(v > 50)v=100;\nv\n\n\n\nJumpy Wiggle 2 is similar to 1, but works at a defined FPS so your "jump" will happen at a regular pace.\n\n\n// Jumpy Wiggle 2 (moves at a defined FPS)\nfps=5; //frequency\namount=50; //amplitude\nwiggle(fps,amount,octaves = 1, amp_mult = 0.5,(Math.round(time*fps))/fps);\n\n\n\n\nSometimes you just want something to move constantly without keyframing it. Use throw.\n\n// Throw (move at a constant speed without keyframes)\nveloc = -10; //horizontal velocity (pixels per second)\nx = position[0] + (time - inPoint) *veloc;\ny = position[1];\nz = position[2];\n[x,y,z]\n\nCreate an eased repeating motion in constant increments:\n\nf = timeToFrames(time);\nline = Math.floor(f/25);\npix = Math.min(f%25,10);\npixe = ease(pix, 0, 10, 0, 60);\nvalue - [0, line*60+pixe]\n\nto make it go up or down just change:  value - [0, line*60+pixe] to value +[...\n\n\nSpin is the same as throw, but for rotation.\n\n// Spin (rotate at a constant speed without keyframes)\nveloc = 360; //rotational velocity (degrees per second)\nr = rotation + (time - inPoint) *veloc;\n[r]\n\n//Autofade: Add to opacity\ntransition = 20;       // transition time in frames\nif (marker.numKeys<2){\ntSecs = transition / ( 1 / thisComp.frameDuration); // convert to seconds\nlinear(time, inPoint, inPoint + tSecs, 0, 100) - linear(time, outPoint - tSecs, outPoint, 0, 100)\n}else{\nlinear(time, inPoint, marker.key(1).time, 0, 100) - linear(time, marker.key(2).time, outPoint, 0, 100)\n}\n\n//Snap zoom in and out: apply to scale\nsnapScale = 300; //percent of scale to zoom\n\ntrans = 4; //  transition time in frames\ntrans = trans * thisComp.frameDuration;\ninTrans  = easeOut(time, inPoint, inPoint + trans, [snapScale,snapScale], [0,0]);\noutTrans = easeIn(time, outPoint, outPoint - trans, [0,0], [snapScale, snapScale]);\nvalue+ inTrans + outTrans\n\n// Y Axis Jitter\n\n\nprobability = 8 ;  //higher is less likely\npos = 50;\nval  = random(-probability-2, 1);\nm = clamp(val, 0, 1);\ny = wiggle(10, pos*m)-position;\nvalue + [0, y[1]]\n\n3D layer invisible while facing backwards to camera (use on Opacity):\nif (toCompVec([0, 0, 1])[2] > 0 ) value else 0\n\nParent Puppet pin to Null (there is a script on AEscripts for this also I believe, haven\'t used it):\nn=thisComp.layer("NullObject_Name");\nnullpos=n.toComp(n.anchorPoint);\nfromComp(nullpos);\n\nNumbers:\nAdd a slider and name to \'Value\'\n\nplaces = 3; //number of decimal places desired\nval = effect("Value")("Slider"); //sub in the name of your slider here\n\nfactor = Math.pow(0.1, places) ;\nsign = "";\nif (val < 0) sign = "-";\n\nval = Math.abs(val);\nwhole = Math.floor(val);\nfraction = "" + Math.round((val - whole)/factor)*factor;\n\nfor (fraction; fraction.length < places+2; fraction+="0");\n\nsign + whole + "." + fraction.substring(2, places+2)\n\nPosition from layer above\nthisComp.layer(index - 1).transform.position\n\nNumber of decimal places\n//--Begin Expression\n\nnums = thisComp.layer("Deep Lime Green Solid 1").effect("Slider Control")("Slider");\nnumOfPlaces = 3;\n//--Do not modify below this line\n\nfunction roundTo(number, places)\n{\nnum = Math.round ( Math.pow(number, places) );\n}NUMBER ROUNDING\nmyNumber = 23.3453255243697978;\nround(myNumber, 2);\n\nfunction round(aNum, dP) {\n      return(Math.round(aNum*Math.pow(10, dP))/Math.pow(10, dP));\n}\nnum /= Math.pow(10, places);\nreturn num;\n}\n\nroundTo(nums, numOfPlaces)\n\n//--End expression\n\nRound decimal\nMath.round(your_decimal_number_here)\n\nRANDOM MOVEMENT\n//Returns two values by default; [x-pos. y-pos]\nsegDur = .5;// duration of each "segment" of random motion\nminVal = [0.1*thisComp.width, 0.1*thisComp.height];\nmaxVal = [0.9*thisComp.width, 0.9*thisComp.height];\n\nseed = Math.floor(time/segDur);\nsegStart = seed*segDur;\nseedRandom(seed,true);\nstartVal =  random(minVal,maxVal);\nseedRandom(seed+1,true);\nendVal = random(minVal,maxVal);\nease(time,segStart,segStart + segDur, startVal, endVal);\n\nTime Output\n//Contains rounding + always display 2 digits\n\nmin = Math.floor(time);\nstrMin = String(min);\nif(min < 10){\n   strMin = \'0\' + strMin;\n}\n\nsec = Math.round(((time) - min)*100);\nstrSec = String(sec);\nif(sec < 10){\n   strSec = \'0\' + strSec;\n}\n\n"18:22:" + strMin + ":" + strSec\n\n\nRandom Letters\n//Begin expression\nnumOfLetters = 25; //Modify me\nuseSpaces = true; //Modify me\nchangeEveryFrame = true; //Modify me\n\n//Don\'t modify below this line\n\nseedRandom(index, !changeEveryFrame)\n//--\nfunction genLetter( ) {\nr = random(65, 90);//from a to z\nreturn String.fromCharCode( r );\n}\ns = "";\nfor(i = 0; i < numOfLetters; i++)\n{\ns += genLetter();\nif(useSpaces)\ns += " ";\n}\ns\n//End expression\n\nLoop\n//Looping Script\nfreq = 0.6;\namp = 5;\nloopTime = 10;\nt = time % loopTime;\nwiggle1 = wiggle(freq, amp, 1, 0.5, t);\nwiggle2 = wiggle(freq, amp, 1, 0.5, t - loopTime);\nlinear(t, 0, loopTime, wiggle1, wiggle2)\n\n\nRandom Position HOLD\n\nholdTime = .5; //time to hold each position (seconds)\nminVal = [0.1*thisComp.width, 0.1*thisComp.height];\nmaxVal = [0.9*thisComp.width, 0.9*thisComp.height];\n\nseed = Math.floor(time/holdTime);\nseedRandom(seed,true);\nrandom(minVal,maxVal)\nSmooth Keyframes\nsmooth(width = .2, samples = 5, t = time)\n\nCreating Trails\ndelay = 5; //number of frames to delay\n\nd = delay*thisComp.frameDuration*(index - 1);\nthisComp.layer(1).position.valueAtTime(time - d)\n\nOR\nthisComp.layer(index+1).transform.position.valueAtTime(time-.1)\n\n        \n\nWiggle X axis only\n\n[wiggle(5,30)[0],value[1]]\n\nWiggle Y axis only\n\n[value[0],wiggle(1,100)[1]]\n\n\nSmooth Wiggle\nhttp://forums.adobe.com/message/1799293#1799293\n\nseedRandom(time*5);\nwiggle(0,100);\n\nCopy size and rescale from layer above\nthisComp.layer(index - 1).scale-[7,7]\n\n\n\nCopy rotation from layer below and rotate 22.5\nthisComp.layer(index+1).transform.rotation+22.5\n\n\n\nCopy position from layer above\nthisComp.layer(index-1).position\n\n\nKeep x at 960, move Y X time * 100 pixels\n\n[960, position[1]+time*-100]\n\n\n\nLock a layer to the exact centre of the comp (very useful for rotoscoping where you accidentally nudge the layer all the time)\n\nOn the (2D, comp size) layer\u2019s Position:\n[comp.Length/2, comp.Height/2]\n\n\nTime delay from layer above\nthisComp.layer(index+1).transform.position.valueAtTime(time-.1)\n\nWiggle in one direction only\nWiggle Y Only:\n\n[value[0],wiggle(1,100)[1]]\n\nWiggle X Only:\n\n[wiggle(5,30)[0],value[1]]\n\nWiggle X and Y separately:\n\n[wiggle(5,30)[0],wiggle(1,100)[1]]\n\n\nLoop Types\nloopOut("pingpong")  // ABCD(CBABCDCBA)\nloopOut("continue") // ABCD(EFGHIJKL)\nloopOut("Cycle")  // ABCD(ABCDABCD)\n\n\nRange Mapping\ninput = effect("Slider Control")("Slider");\ninputLow = 0;\ninputHigh = 100;\noutputLow = -100;\noutputHigh = 100;\n\nlinear(input,inputLow,inputHigh,outputLow,outputHigh)\n\n\nFor when you want burn in text to automatically display the layer name (i.e. render out tiff sequence first, then making a QT w/ name burn in).\n\nMake text layer, add expression to \'source text\'. \n\nfunction pad(number, length) { var str = \'\' + number; while (str.length < length) { str = \'0\' + str; } return str; } var theLayerName = thisComp.layer(index+1).name; var theLayerNameSplit = theLayerName.split(\'.\'); theLayerNameSplit[0];\n\nTo change which layer is read for the name, change the (index+1) to (index+2) and so on. \n\n\nCounting numbers with comma:\n\nstartCount = 0;\nendCount = 11689;\ncountDur = 1.2;\ns = "" + Math.round(linear(time,0,countDur,startCount,endCount));\n\nif (s.length > 3){\ns.substr(0, s.length -3) + "," + s.substr(-3);\n}else{\ns\n}\n\n\nOscillate Rotation\n\nUse Expression Control angles or sliders for \u201c from\u201d, \u201cto\u201d, and an Expression\nControl slider assigned to \u201cperiod\u201d for fine control. You can apply these to any layer.\nChange \u201clinear\u201d to \u201cease\u201d for smoother interpolation.\nby Michael Natkin & Brian Maffitt\n\n\nfrom = -45; //one end of your oscillation\nto = 45; //the other end of your oscillation\nperiod = 1.5; //time between oscillation points (multiply by 2 for a round trip)\nt = time % (period * 2);\nif (t > period) t = 2 * period - t;\nlinear(t, 0, period, from, to)\n\n\nGrayscale Value to x,y Data\n(x&y outputs will range from 0-100)\n\nsourceLayer = thisComp.layer(\u201clayer");\nsampleSize = [1,1];\nsamplePoint = transform.position;\ncolor= sourceLayer.sampleImage(samplePoint,sampleSize);\nx=color[0]*100\ny=color[0]*100\n[x,y]\n\n\nPercentage Counter With Slider Control:\n\nslider = effect("Slider Control")("Slider");\nnumDecimals = 0;\ncommas = false;\ndollarSign = false;\npercentSign = true;\ns = slider.value.toFixed(numDecimals);\nprefix = "";\nsuffix = "";\nif (s[0] == "-"){\n  prefix = "-";\n  s = s.substr(1);\n}\nif(dollarSign) prefix += "$";\nif(percentSign) suffix = "%";\nif (commas){\n  decimals = "";\n  if (numDecimals > 0){\n    decimals = s.substr(-(numDecimals + 1));\n    s = s.substr(0,s.length - (numDecimals + 1));\n  }\n  outStr = s.substr(-s.length, (s.length-1)%3 +1);\n  for (i = Math.floor((s.length-1)/3); i > 0; i--){\n    outStr += "," + s.substr(-i*3,3);\n  }\n  prefix + outStr + decimals + suffix;\n}else{\n  prefix + s + suffix;\n} \n\n\n\n\n\n\n\nRounding Numbers:\n\nMath.round(value)\nrounds the number\n\nMath.ceil(value)\nrounds up\n\nMath.floor(value)\nrounds down\n\nScaling 3d layers while moving active camera:\n\ncam = thisComp.activeCamera; \ndistance = length(sub(position, startPoint.position)); \nscale * distance / cam.zoom;\n\n\n\n\n\n\nValue change over time\n\nvalue = "Hello";\nif (time >= 1){\nvalue = "Goodbye"\n}\n\n\n\nSmooth Credits (Or constant motion on the Y Axis)\n\nApply this to position and then move the anchor point to position your credits. Change S to change the speed or direction of the credits\nt = time;  \nfr = t/thisComp.frameDuration;  \nx = value [0];  \ns = -6; //Speed in pixels per frame  \n[x, fr*s]  \n\n\n\n\nCenter the Anchor Point in a text layer - automatically adjusts with changes\n\nvalue-[0,this.sourceRectAtTime(time).hei\xadght/2]\n\nThe same, but both axis\nx = this.sourceRectAtTime(time).left+this.sourceRectAtTime(time).width/2;\ny = this.sourceRectAtTime(time).top+this.sourceRectAtTime(time).height/2;\n \n[x, y]\n\n\nRandom Grid Movement\nhttp://www.motionscript.com/expressions-lab-ae65/random-grid-movement.html\n\nmove objects randomly along a grid to a new position on the grid.\nTry applying this expression to the position property of a square solid and then duplicated the solid a bunch of times.\nNote that the number of rows is calculated from the number of columns and that the objects come to rest at the intersection of rows and columns.\nAdjust the number of columns, hold time, minimum and maximum cycle time to suit your needs.\n\n\ncolumns = 23.41; //number of columns in grid\ntHold= .2; //hold time (must be less than tmin)\ntMin = 1; //minimum cycle time (can\'t be zero)\ntMax = 1.2 //maximum cycle time\n\ngap = this_comp.width/columns;\norigin = [gap,gap];\nxGrid = columns - 1;\nyGrid = Math.floor(this_comp.height/gap) - 1;\n\nstart = 0;\nend = 0;\nj = 1;\n\nwhile (time >= end){\n  j += 1;\n  seedRandom(j,true);\n  start = end;\n  end += random(tMin,tMax);\n}\ntargetX = Math.floor(random(0,xGrid)); \ntargetY = Math.floor(random(0,yGrid)); \nseedRandom(j-1,true);\nx = random(); //this is a throw-away value\noldX = Math.floor(random(0,xGrid)); \noldY = Math.floor(random(0,yGrid)); \n\nif(targetX == oldX && targetY == oldY){\n  origin + [oldX,oldY]*gap;\n}else if (time - start < tHold){\n  origin + [oldX,oldY]*gap;\n}else{\n  deltaX = Math.abs(targetX - oldX);\n  deltaY = Math.abs(targetY - oldY);\n  xTime = (end - start - tHold)*(deltaX/(deltaX + deltaY));\n  yTime = (end - start - tHold)*(deltaY/(deltaX + deltaY));\n  if (time < start + tHold + xTime){\n    startPos = origin + [oldX,oldY]*gap;\n    targetPos = origin + [targetX,oldY]*gap;\n    easeOut((time - start - tHold)/xTime, startPos, targetPos);\n  }else{\n    startPos = origin + [targetX,oldY]*gap;\n    targetPos = origin + [targetX,targetY]*gap\n    easeIn((time - start - tHold - xTime)/yTime, startPos, targetPos);\n  }\n}\n\n\n\nOffset one axis separately for linked comps in 3D space\n\nthePos = comp("MainComp").layer("Your3DLayer").transform.position;\n[thePos[0]+offset, thePos[1]+offset, thePos[2]+offset]\n\n\nIMPACT BOUNCE (bounce back after impact, like slamming doors, bouncing ball)  You can apply it to Position, but it will work with any key-framed parameters (scale, opacity etc)\n\ne = .7;\ng = 5000;\nnMax = 9;\nn = 0;\nif (numKeys > 0){\n n = nearestKey(time).index;\n if (key(n).time > time) n--;\n}\nif (n > 0){\n t = time - key(n).time;\n v = -velocityAtTime(key(n).time - .001)*e;\n vl = length(v);\n if (value instanceof Array){\n   vu = (vl > 0) ? normalize(v) : [0,0,0];\n }else{\n   vu = (v < 0) ? -1 : 1;\n }\n tCur = 0;\n segDur = 2*vl/g;\n tNext = segDur;\n nb = 1; // number of bounces\n while (tNext < t && nb <= nMax){\n   vl *= e;\n   segDur *= e;\n   tCur = tNext;\n   tNext += segDur;\n   nb++\n }\n if(nb <= nMax){\n   delta = t - tCur;\n   value +  vu*delta*(vl - g*delta/2);\n }else{\n   value\n }\n}else\n value\n\n\n\nAdjust a single value (parameter) of an effect on a layer, the further away the layer is from the camera. For this example, it was applied to \'brightness\', to make the layer paler as it moves into the distance:\n\nC = thisComp.activeCamera;\nstart = 2500;\nend = 25500;\nd = length(toWorld(anchorPoint),C.toWorld([0,0,0]));\nlinear(d,start,end,0,100)\n\n\'start\' is the distance the layer is from camera that the expression begins.\n\'end\' is the distance that the expression reaches maximum effects.\n\nThe red numbers indicate the minimum and maximum values returned for any parameter. Change the \'100\' to \'60\' (for example) and \'brightness\' will never go higher than 60. \n\n\n\n\nLinks position value of effects (corner pin, beam etc etc) to postion of Null (or any layer be it 2d or 3d)\nApply this to position value in Effect:\ntarget = thisComp.layer("Layer"); // Layer is the layer your want to get the position value from\nfromComp(target.toComp(target.anchorPoint));\n\n\n\n\nOscillate a value with Math.sin\n\namp = 3; //sine wave amplitude (pixels)\nfreq = 0.5; //oscillations per second\n\nx = amp*Math.sin(freq*time*2*Math.PI);\n[x]\n\n\nLooping Wiggle: \n\nfreq = 1;\namp = 110;\nloopTime = 3;\nt = time % loopTime;\nwiggle1 = wiggle(freq, amp, 1, 0.5, t);\nwiggle2 = wiggle(freq, amp, 1, 0.5, t - loopTime);\nlinear(t, 0,  loopTime, wiggle1, wiggle2)\n\n\nhttp://www.motionscript.com/design-guide/looping-wiggle.html\n\n\nCOUNTING NUMBERS (above 1 Million)\nCreate a new text layer. Add the following expression to source text. Adjust the variables to do whatever you need.\n\n//begin code\n\nstartTime = 0; //seconds\nendTime = 5; //seconds\nbeginCount = 0;\nendCount = 2000;\nhasCommas = true;\n//--dont modify below here----------------\nfunction addCommas ( s ){\nif( s.length <= 3 )\nreturn s;\nelse\nreturn s.substring(0 , 3) + "," + addCommas(s.substring(3, s.length));\n\n}\nfunction reverse( s ){\nnewStr = "";\nfor(i = s.length-1; i >= 0; i--)\nnewStr += s.charAt(i)\nreturn newStr;\n}\n\nval = Math.round (linear(time, startTime, endTime, beginCount, endCount) );\nif( hasCommas )\nreverse (addCommas(reverse( val + "" )))\nelse\nval\n\n\n//end code\n\n\n// CODE FOR SPLITING LAYERS\n\n// store all keytime values into arrayKeyTimes;\n\n// then take the in and out point values\nvar inPointValue = layer.inPoint;\nvar outPointValue = layer.outPoint;\n\nfor (var i = 0; i<=n; i++)  {\n    \n   layer.duplicate();\n   layer = thisComp.layer(1);\n   layer.inPoint = (i == 0) ? inPointValue : arrayKeyTimes[i-1];\n   layer.outPoint = (i < n) ? arrayKeyTimes(i) : outPointValue;\n\n}\n\nCopy the expression, Alt-Click the Scale stopwatch, Paste):\nn = 0;\nif (marker.numKeys > 0){\n  n = marker.nearestKey(time).index;\n  if (marker.key(n).time > time){\n    n--;\n  }\n}\n\nif (n == 0){\n  value;\n} else {\n  max_dev=20; // max deviation in pixels\n  spd=35; //speed of oscillation\n  decay=10; //how fast it slows down\n  t = time - marker.key(n).time;\n  s = max_dev*Math.sin(spd*(t))/Math.exp(decay*t);\n  value + [s,s];\n}\nSo wherever you place a marker you\'ll get the old squish and squash. Hit the asterisk (*) key on the numeric pad to drop a marker wherever you are on the timeline.\nNote: No marker, no squish and squash. Five markers give five squish and squashes.\nAlso if you\'re talking a diferent expression, just drop that in below the }else{.\nby Mike Clasby (yikesmikes)\n\nMore Natural Easing\nn = 0;\nif (numKeys > 0){\nn = nearestKey(time).index;\nif (key(n).time > time){\nn--;\n}\n}\nif (n == 0){\nt = 0;\n}else{\nt = time - key(n).time;\n}\nif (n > 0){\nv = velocityAtTime(key(n).time - thisComp.frameDuration/10);\namp = .05;\nfreq = 2.0;\ndecay = 4.0;\nvalue + v*amp*Math.sin(freq*t*2*Math.PI)/Math.exp(decay*t);\n}else{\nvalue;\n}\n\n\n\n Evenly distribute layers between 2 other layers\nn = thisComp.numLayers;\nif (n > 2){\np1 = thisComp.layer(1).transform.position;\np2 = thisComp.layer(n).transform.position;\nlinear(index,1,n,p1,p2)\n}else{\nvalue\n}\n\nSCRIPT TO FLIP OBJECT BASED ON VELOCITY\n\n\n//plug this into SCALE\nif (transform.position.velocity[0] <=0){\n[-value[0], value[1]]\n}\nelse{\n[value[0], value[1]]\n}\n\nSTEREO CAMERA RIG FIX\n\n///////////STEREO RIG FIX - Be sure to set the 3d stereo rig units to pixels, not percentage\n///// L camera is + N, R camera is - N\nN = thisComp.layer("Stereo 3D Controls").effect("3D Glasses")("Scene Convergence");\n[value[0] + N, value[1]]\n\n\n\n// Layer Autofacing camera \n\nL = comp("COMPNAME").layer("Camera 1");\nu = fromWorldVec(L.toWorldVec([1,0,0]));\nv = fromWorldVec(L.toWorldVec([0,1,0])); \nw = normalize(fromWorldVec(L.toWorldVec([0,0,1]))); \n\nsinb = clamp(w[0],-1,1);\nb = Math.asin(sinb);\ncosb = Math.cos(b);\nif (Math.abs(cosb) > .0005){\n  c = -Math.atan2(v[0],u[0]);\n  a = -Math.atan2(w[1],w[2]);\n}else{\n  a = (sinb < 0  ?  -1 : 1)*Math.atan2(u[1],v[1]);\n  c = 0;\n}\n[radiansToDegrees(a),radiansToDegrees(b),radiansToDegrees(c)]\n\nTIME EXPRESSION\n\ncountspeed = 1;\nclockStart = 0;\n \nfunction times(n){\n  if (n < 10) return "0" + n else return "" + n\n}\n \nclockTime = clockStart +countspeed*(time - inPoint);\n \nif (clockTime < 0){\n  minus = "-";\n  clockTime = -clockTime;\n}else{\n  minus = "";\n}\n \nt = Math.floor(clockTime);\nh = Math.floor(t/3600);\nmin = Math.floor((t%3600)/60);\nsec = Math.floor(t%60);\nms = clockTime.toFixed(3).substr(-3);\nminus + times(h) + ":" + times(min) + ":" + times(sec) + "." + ms\n\n\n\n\n\nmaintain stroke weight \n(modified from Adam Plouff)\nif(hasParent){\np =Math.abs(parent.scale[0]) ;}\nelse{p=100;}\ns = Math.abs(transform.scale[0]); \nscaleFactor = 100/s;\nPscaleFactor = 100/p;\nvalue*scaleFactor*PscaleFactor;\n\nPULSE EFFECT\n//Change Freq for times per sec and amp for how hard you want the pulse. Adjust value at bottom to x,x to effect both x and y values.\nfreq = 2; \namp = 15;\nx = amp*Math.sin(freq*time*Math.PI*2);\nvalue + [x,0]\n\n\n\nMove along X over time\n\nvel = -25; //speed of the movement.\n[vel*time+value[0], value[1]]\n\n\nFollow \u201cleader\u201d layer position with added time delay. \n\nPut expression in Position of all following layers.\nAll follower layers must be placed directly beneath the leader layer. \nIf the leader layers layer-number is other than 1, replace the (1) in the expression.\nTip: If you delete the delay value number and pickwhip \u201cvalue\u201d of an expression slider effect (for example a slider in the leader layer) you can easily change the delay of all follower-layers at the same time.\n\ndelay = 0.5;\nleader = thisComp.layer(1); \nleader.transform.position.valueAtTime(time - delay*(index-leader.index)); \n\nThis expression can be applied to any property, just change the word \u201cposition\u201d to \u201cscale\u201d, \u201copacity\u201d, or any desired property.\nADD: How to make this work with wiggle on the same layer? wiggle and this cancel each other out.\n\n\n\n\n'})})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},1683:(n,e,t)=>{t.d(e,{A:()=>i});const i=t.p+"assets/images/image-e53cad317060c5f1fcb115a5c6498925.png"},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(n){const e=i.useContext(a);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);