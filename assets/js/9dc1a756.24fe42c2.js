"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[157],{8132:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>u,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=t(4848),i=t(8453);const o={},u="Linear Interpolation Expression Based",l={id:"maya/programming/example/linear_interpolation_expression_base",title:"Linear Interpolation Expression Based",description:"20 Mar 2024",source:"@site/docs/maya/programming/example/linear_interpolation_expression_base.md",sourceDirName:"maya/programming/example",slug:"/maya/programming/example/linear_interpolation_expression_base",permalink:"/docs/maya/programming/example/linear_interpolation_expression_base",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/maya/programming/example/linear_interpolation_expression_base.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Create Joints from Every Cvs of Curve",permalink:"/docs/maya/programming/example/create_joints_from_every_cvs_of_curve"},next:{title:"list_materials_in_a_scene_3DS_max",permalink:"/docs/maya/programming/example/list_materials_in_a_scene_3DS_max"}},r={},p=[];function s(e){const n={code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"linear-interpolation-expression-based",children:"Linear Interpolation Expression Based"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"20 Mar 2024"}),"\nAdvance Skeleton has its own driving system and even features pose interpolation. Unfortunately, it does not work well if the rig is asymetrical. Hence, making a separate simple script below."]}),"\n",(0,a.jsx)(n.p,{children:"This one works for most cases since its for a scapula driver where it will most likely be rotated in one axis."}),"\n",(0,a.jsx)(n.p,{children:"But maybe implement an expression based RBF next time?"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-C",children:"proc float lerp(float $a, float $b, float $t) {\n    return (($b - $a) * $t) + $a;\n}\n\n\n// Rotate X\nfloat $minBase = 0.0;\nfloat $maxBase = -40.0;\nfloat $minTarget = 0.0;\nfloat $maxTarget = -2.958;\n\nfloat $orig_val = FKScapula_R.rotateY;\nfloat $new_val = lerp($minTarget, $maxTarget, ($orig_val - $minBase) / ($maxBase - $minBase));\nFKExtrashoulderPad01_R.rotateX = $new_val;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"22 June 2022"}),"\nAnother usage for linear interpolation but to mirror the Set Driven Key Relationship.\nI find myself using this compared to SDK since SDK is broken once you delete the node but expression based connection still works as long as you have a consistent name"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-C",children:"// Define the input attribute\nfloat $input = AimEye_M.right_eye_blink;\n\n// Define the input range\nfloat $inputMin = 0.0;\nfloat $inputMax = 1.0;\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = 30.0;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_R_main_jnt.rotateY = $mappedValue;\n\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"Another version:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-C",children:"// Define the input attribute\nfloat $input = AimEye_M.right_eye_blink;\n\n// Define the input range\nfloat $inputMin = 0.0;\nfloat $inputMax = 1.0;\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = 30.0;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_R_main_jnt.rotateY = $mappedValue;\n\n////////////////////////////////\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = 0.601;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_R_02_jnt.translateX = $mappedValue;\n\n\n////////////////////////////////\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = 0.32;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_R_01_jnt.translateX = $mappedValue;\n\n/////////////////////////////////\n\n// Define the input attribute\nfloat $input = AimEye_M.left_eye_blink;\n\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = 30.0;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_L_main_jnt.rotateY = $mappedValue;\n\n/////////////////\n\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = -0.601;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_L_02_jnt.translateX = $mappedValue;\n\n////////////////////////////////\n\n// Define the output range\nfloat $outputMin = 0.0;\nfloat $outputMax = -0.32;\n\n\n// Calculate the normalized value (0 to 1)\nfloat $normalizedValue = ($input - $inputMin) / ($inputMax - $inputMin);\n\n// Map the normalized value to the output range\nfloat $mappedValue = $outputMin + ($normalizedValue * ($outputMax - $outputMin));\n\n// Assign the mapped value to the desired attribute\nupper_eyelid_L_01_jnt.translateX = $mappedValue;\n"})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>u,x:()=>l});var a=t(6540);const i={},o=a.createContext(i);function u(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:u(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);