"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9052],{8242:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>h});var o=i(4848),t=i(8453);const s={},l="CHOPS",a={id:"houdini/chops/index",title:"CHOPS",description:"CHOPS",source:"@site/docs/houdini/chops/index.md",sourceDirName:"houdini/chops",slug:"/houdini/chops/",permalink:"/docs/houdini/chops/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/houdini/chops/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Houdini",permalink:"/docs/houdini/"},next:{title:"Composting (COPS)",permalink:"/docs/houdini/compositing/"}},r={},h=[{value:"CHOPS",id:"chops-1",level:2}];function d(e){const n={h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"chops",children:"CHOPS"}),"\n",(0,o.jsx)(n.h2,{id:"chops-1",children:"CHOPS"}),"\n",(0,o.jsx)(n.p,{children:"chops lag node.\nslope and trigger chop"}),"\n",(0,o.jsx)(n.p,{children:"extend chop to loop the cycle\nrange map in CHOPS is in math node."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"cops mosaic node."}),"\n",(0,o.jsx)(n.li,{children:"in the user interface, the rotation is in degrees."}),"\n",(0,o.jsx)(n.li,{children:"in vex, it is in radians."}),"\n",(0,o.jsx)(n.li,{children:"in the attribute scope channel sope."}),"\n",(0,o.jsx)(n.li,{children:"P.x doesn't work. It has to be P(0)"}),"\n",(0,o.jsx)(n.li,{children:"envelope helps you to smooth out the incoming signals."}),"\n",(0,o.jsx)(n.li,{children:"mops ignore zero fall offf prims"}),"\n",(0,o.jsx)(n.li,{children:"the mops delay is not actually the equivalent for c4d delay effector"}),"\n",(0,o.jsx)(n.li,{children:"it would mops springs effector"}),"\n",(0,o.jsx)(n.li,{children:"If you'd like to generate stepped curves, try using the Count CHOP."}),"\n",(0,o.jsx)(n.li,{children:"Your CHOP track names need to be absolute paths. Otherwise they will not work."}),"\n",(0,o.jsx)(n.li,{children:"Geometry in CHOPs don't scale well. Simply because you are layering channels over geometry attributes, and other simulation data. Try avoiding this at all costs."}),"\n",(0,o.jsx)(n.li,{children:"CHOP Any nodes associated with this network type are built for editing animation curves and audio data."}),"\n",(0,o.jsx)(n.li,{children:"Pretty much anything that involves a curve, creates a curve through motion, or has a relation to cos,tan and sin can be edited in a CHOP network."}),"\n",(0,o.jsx)(n.li,{children:"velocity damping is in the actual vellum solver."}),"\n",(0,o.jsx)(n.li,{children:"Single threaded. One of the most oldest system/feature in Houdini. Long overdue of overhaul."}),"\n",(0,o.jsx)(n.li,{children:"Filter node is the one that makes a smoother transition. Like smoothing simulation too."}),"\n",(0,o.jsx)(n.li,{children:"Noise. Pulse Node."}),"\n",(0,o.jsxs)(n.li,{children:["Fetch node is like import or object merge node but in CHOPS","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"can also use geometry node to fetch from the SOPs land."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Graph per single channel is also a good thing."}),"\n",(0,o.jsx)(n.li,{children:"Math - post channel positive"}),"\n",(0,o.jsx)(n.li,{children:'chop("../chopnet1/OUT/rx")'}),"\n",(0,o.jsx)(n.li,{children:"Set to frames instead of seconds on the  CHOPs much easier."}),"\n",(0,o.jsx)(n.li,{children:"Math node can also do multiply the chop nodes. wtf haha"}),"\n",(0,o.jsxs)(n.li,{children:["Okay this is the part where CHOPs makes it slow","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"supposing you have 120 packed points being used to copy some objects."}),"\n",(0,o.jsxs)(n.li,{children:["To use chops, you also need a 120 channels to work with to match each point. - You can also have lesser channels","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"if you have only 1 channel then same animation will remap to 120 points."}),"\n",(0,o.jsx)(n.li,{children:"if you have 10 channel, then every 12 channel has the same animation data."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"And this having many channels is grinds it to a hault. if you have 200 frames. Then you will be viewing 24,000 (200 x 120) at a given time as motion fx editor views all data of all timeline and not per frame."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Yea that copy to stamp old is abit tricky. Might need to reference the file again and again. copy to stamp was replace in favor of the for loop block"}),"\n",(0,o.jsx)(n.li,{children:"Discovered that the files not working were 24 bit, when playing 16 bit audio everything is ok."}),"\n",(0,o.jsx)(n.li,{children:"The only time to worry about the CHOPS being transferred to SOPS for animated sequence is through the channel SOP. If you are referencing through expresssion, it will be instally referred as animated"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Audio Processing"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Only in chops where you can process audio"}),"\n",(0,o.jsx)(n.li,{children:"Use parameter EQ to isolate one drum sound"}),"\n",(0,o.jsx)(n.li,{children:"Normally you have two channel, you can just delete the other one through delete node."}),"\n",(0,o.jsx)(n.li,{children:"H to zoom in motion fx view"}),"\n",(0,o.jsx)(n.li,{children:"If you are working with audio you will have to that speaker icon render view available to your nodes"}),"\n",(0,o.jsx)(n.li,{children:"Use envelope node to dwon sample an audio. For animation purposes, you don't need that high samples all the time (44khz)"}),"\n",(0,o.jsx)(n.li,{children:"Use trigger to have a visually binary data removing noise/audio that is not part of the trigger threshold."}),"\n",(0,o.jsx)(n.li,{children:"Resample then pulse reserve"}),"\n",(0,o.jsxs)(n.li,{children:["hold node with the inputs as noise and binary data from the trigger node","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"nice. instead of the constant 0 1 pulse. you get a random range of 0 to 1."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"there is even a logic node."}),"\n",(0,o.jsx)(n.li,{children:"count chop"}),"\n",(0,o.jsx)(n.li,{children:"and there is also a copy stamp haha. so complicated."}),"\n",(0,o.jsx)(n.li,{children:"$C refers to per channel data. Allows you to have different data per channel like for seed and offset."}),"\n",(0,o.jsxs)(n.li,{children:["Ahh. Finally the automatic detectioon of what is the minimum and maximum of the incoming data","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"icmin(0,0) and icmax(0,0). only works for chops though since in chops the data is for the whole timeline/range and not per frame (like in SOPs)"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"CHOP fetch parameter?"}),"\n",(0,o.jsx)(n.li,{children:"event triggered audio"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"CHOPS per Point"})})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function l(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);